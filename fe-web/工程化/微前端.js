/*
 * @Author: liyu38 liyu38@meituan.com
 * @Date: 2022-05-07 15:31:23
 * @LastEditors: liyu liyu38@meituan.com
 * @LastEditTime: 2022-07-20 11:15:23
 * @FilePath: /examples/fe-web/工程化/微前端.js
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * 参考文档：
 *  https://juejin.cn/post/7004661323124441102
 * https://github.com/woai3c/Front-end-articles/issues/31（教程）
 * https://qiankun.umijs.org/ 乾坤
 * node-module: 企业
 */
/**
 * 1. 在业务中落地微前端实际遇到什么问题，或者说micro的目标是
 *    解耦巨石应用
 *    落地微前端，根据业务或者模块拆分系统，可以更好的维护
 *    独立开发，独立部署，独立上线
 *    与技术栈无关
 *    形成开发体系
 *  1.1 主应用+子应用体系采用怎样的运行时框架
 *    社区：乾坤，静态资源版本
 *  1.2
 * 2. 微前端体系
 *  2.1 治理体系
 *    应用管理 依赖管理 产物管理 版本发布 灰度方案 私有化
 *  2.2 运行时容器
 *    应用加载 生命周期 路由同步 应用通信 隔离沙箱 异常处理
 *  2.3 开发配套
 *    文档 脚手架 dev 构建 发布 devtools(CI/CD)
 *  2.4 微物料
 *    粒度不一的资源体系
 *
 *
 *
 *
 *
 *
  */



/**
 * @description: 企业内部的微前端方案拆解
 * 1: 思想是组件即服务，可以将应用或者单组件改造成云组件（用唯一的id关联，托管静态资源即可）
 *    1.1 container组件，实现动态组件/动态配置的基础（调度，管理静态资源）
 *    1.2 可视化管理端：策略下发，版本下发，配置中心
 *    1.3 cli工具
 * 2: 提供容器组件通过获取相应的静态资源，此时相比之前浏览器接管，容器接管静态资源做了什么工作（如此设计的目的是什么）
 *    2.1 template构造类
 *      2.1.1: 看起来定义了完整的生命周期，从启动到结束
 *      2.1.2: 容器组件起到代理的作用，edcId 关联的组件获取的是组件相关的静态资源链接（并不是直接获取静态资源，此时只是获取对应的链接）
 *      2.1.3: template类获取script，插入文档，获取style链接，插入文档
 *    2.2 instance 构造类
 *      2.2.1 管理instance 的构造函数，而具体的方法在registry 类，而 instance 实例包含template属性
 *    2.3 registry构造类
 *      2.3.1 registry里管理调度instance 和 template
 * 3. container 容器
 *    3.1 实现 edcInstance，看起来就是渲染一个vue组件的各种属性（将静态资源手动渲染成需要的结构）
 * 4. 核心原理： 总体理解是基于静态资源管理云组件，加工静态资源，注入宿主环境配置，渲染成相应的目标产物
 *    4.1 基于静态资源和工程化配置生成 模版&上下文
 *    4.2 桥接组件处理生命周期和实际的渲染过程（以vue为例，使用渲染函数只依赖运行时能力）
 *    4.3 整体在设计上还需要考虑到 性能和模块化以及web的典型能力
 * 5. 组件即服务需要比应用即服务更进一步
 *    5.1 乾坤类框架主要是处理节点替换，动态加载执行静态资源，应用通过生命周期与基座交互
 *    5.2 到了组件这里似乎粒度更小，提供一段静态资源，可以替换页面的dom节点，与当下的技术栈无关（这种动态化能力在微前端/低代码/跨端渲染都可以应用）
 *    5.1 容器组件做了什么
 *      0: 处理组件的生命周期逻辑（对应具体的框架）
 *      1: 根据配置生成edc实例
 *      2: 解析出实例的上下文context，并挂载当前容器组件的属性
 *        2.1 主要是确定edcResources和具体的上下文（对应的数据处理阶段）
 *        2.2 生命周期函数具体执行的都是实例的 callhook,即容器组件生命周期的事情都由edc实例来调度
 *        2.3 此时提问生命周期执行和render函数执行是什么关系
 *        2.4 容器组件的render函数
 *          2.4.1 没有complier，只需要运行时即可，最终生成需要的Vnode
 *      3: 此时看容器组件本身做了什么就比较好理解了
 *        3.1 实现框架本身的生命周期函数逻辑，具体需要做什么由edc实例调度
 *        3.2 执行本身的render函数（render数据来源于edc实例）
 *        3.3 所以得进一步分析edc实例到底包含什么
 *      4. 实例由EDCRegistry提供
 *         4.1 有oop的设计，看起来是管理实例，管理模版，初始化的时候更新配置&开启热更新
 *            4.1.1 createInstance：具有template，context
 *            4.1.2 template 是根据资源请求并处理静态资源，把静态资源插入到html中（至于最终节点往哪渲染会去找el属性，在容器组件里完成）
 *            4.1.3 context 由实例和Registry新建（这里的构造类互相当属性）
 * 6. 总结
 *   6.1 组件即服务提供了动态化的视角，
 *   6.2 应用级别的微前端是拦截路由，切换激活的子应用（失活旧的子应用）
 *      6.2.1 此时入口是子应用的html,会做如下操作
 *        1: 提取 HTML 中 script style 的内容或 URL，如果是 URL，则再次使用 ajax 拉取内容。最后得到入口页面所有的 script style 的内容
 *        2: 将所有 style 添加到 document.head 下，script 代码直接执行
 *        3: 将剩下的 body 部分的 HTML 内容赋值给子应用要挂载的 DOM 下
 *          3.1 对于传统spa项目就是挂载点和动态插入的js，此时就可以保证子应用渲染后对应挂载
 *      6.2.2 组件即服务的思想
 *        1: 获取静态资源即可（无论是应用级别还是组件级别）
 *        2: 容器组件负责组织静态资源，渲染实例，挂载dom,同时维护对应的生命周期钩子
 *      6.2.3 版本管理/工程化角度设计
 *        1: 子应用的上线管理，历史版本管理
 *        2: 包治理，性能优化等等
 */


/**
 * @description qiankun的实现
 * 1. 主应用路由拦截（类似router），监听触发事件的回调
 *    1.1 也包括触发路由变化的事件的监听
 *    1.2 在路由变化时候处理子应用的生命周期
 * 2. 子应用生命周期
 *    2.1 固定执行的事件&暴露给开发者的事件
 * 3. 资源加载与解析(html入口)
 *    3.1 html 中资源路径的拼接
 *      3.1.1 对于本地和实际环境就是静态资源路径的差别
 *    3.2 css/js等资源的解析与加载
 * 4. 性能优化&边界问题讨论
 *
 */

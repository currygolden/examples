
/*
http 基础知识文章参考： https://juejin.cn/post/6844904100035821575
tcp 知识点参考： https://juejin.cn/post/6844904070889603085
浏览器参考：https://juejin.cn/post/6844903553795014663
          https://github.com/poetries/browser-working-principle/blob/master/docs/guide/part1/lesson01.md(浏览器专题解读文章)
*/



/**
 * 浏览器的缓存机制
 * 1. 缓存的方式
 *    强缓存 协商缓存 缓存位置
 * 2. 缓存判断过程
 *    2.1 检查强缓存，这个阶段不需要发送HTTP请求
 *      Expires： 问题在于时间可能不一致
 *      Cache-Control：private no-cache
 *    2.2 强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求
 *      Last-Modified
 *      ETag 基于内容
 *    若命中缓存返回304，告诉浏览器直接用缓存
 * 3. 缓存位置
 *    优先级由高到低 Service Worker/Memory Cache/Disk Cache/Push Cache
 *
 *
 * ==========
 *  浏览器的本地存储
 *  1. cookie
 *    1.1 设计目的：用来做http状态记录，存在跨域限制
 *    1.2 特点：体积上限只有4KB，紧跟域名会导致请求头增大，存在安全问题
 *  2. storage
 *    2.1 只存在客户端，默认不参与与服务端的通信
 *    2.2 容量上限为5M
 *    2.3 可以在客户端做一些数据的持久化存储
 *    2.4 业务中使用本地存储的封装场景
 *
 * ========= 从输入url到页面呈现详细拆解
 *  1. 输入URL到页面呈现发生了什么？——网络篇
 *    1.1 构建请求行
 *    1.2 查找强缓存
 *    1.3 DNS解析：将域名解析成ip地址
 *      1.3.1 从浏览器缓存获取
 *      1.3.2 从本地hosts文件获取
 *      1.3.3 各级域名解析服务器获取
 *         可以看出DNS的解析是一个递归&迭代的过程
 *      1.3.4 分布式服务器，负载均衡，预解析等做DNS解析优化
 *    1.4 建立tcp连接
 *      1.4.1 面向连接的、可靠的、基于字节流的传输层通信协议
 *      1.4.2 3次握手的流程和必要性
 *          c发送syn报文，syn=1,序号为x（初始化序列号，是随机生成的）
 *          s接受后发送应答syn报文，syn=1,ACK=1,确认号ack=x+1,序号y
 *          c发送应答报文syn=1,ACK=1,确认号ack=y+1,序号x+1
 *          必要性是为了保证cs双方正常都有发送和响应的能力，两次只能保证s端不能保证C端
 *      1.4.3 什么是半连接队列
 *          服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列
 *      1.4.4 ISN是固定的吗
 *      1.4.5 4次挥手的流程&必要性
 *          c端发送fin报文，序列号为x
 *          s端发送接受报文ACK=1，ack=x+1,序列号为y
 *          s端发送fin报文，ack=x+1,序列号为k(这里的序列号是新的)
 *          c端发送接受报文，ack=K+1,序号为x+1
 *          经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态
 *          4次是为了服务端的数据发送完毕
 *      1.4.6 四次挥手释放连接时，等待2MSL的意义
 *          保证客户端发送的最后一个ACK报文段能够到达服务端
 *          防止“已失效的连接请求报文段”出现在本连接中
 *    1.5 发送http请求
 *       1.5.1 发送请求行，请求头，请求体
 *          请求行：请求方法、请求URI和HTTP版本协议
 *          请求头：accept,压缩方式，cookie，host
 *          请求体: post请求
 *    1.6 处理网络响应
 *        1.6.1 响应行、响应头和响应体
 *        1.6.2 axios的封装
 * 2. 输入URL到页面呈现发生了什么？——解析篇
 *    2.1 拿到html之后的解析过程
 *        2.1.1 由html字符串构建dom树，即Parse HTML
 *          将 HTML 解析成许多 Tokens，再将 Tokens 转换成 object，最后将 object 组合成一颗 DOM 树
 *        2.1.2 遇到不同类型脚本怎么处理
 *          一般类型的script：暂停解析html,下载解析脚本后再解析html
 *          async: 继续解析html,脚本异步下载，下载后执行此时会中断html的解析，且脚本执行顺序不一定
 *          defer: 继续解析html,脚本异步下载,执行需要等到html全部解析完，不过可以保证脚本顺序
 *        2.1.3 样式计算
 *          CSS 文本转为对象styleSheets
 *          通过继承和层叠计算每个节点的样式，所有的样式值会被挂在到window.getComputedStyle
 *        2.1.4 生成布局树
 *           遍历生成的 DOM 树节点，并把他们添加到布局树中。
 *           计算布局树节点的坐标位置
 * 3. 输入URL到页面呈现发生了什么？——渲染篇
 *    3.1 构建图层树
 *      在拥有布局树之后需要区分图层，也就是层级上下文，z-index
 *    3.2 生成绘制列表，即一系列的绘制指令
 *    3.3 生成图块和生成位图
 *      渲染进程将任务交给合成线程
 *      做的第一件事情就是将图层分块，不是整个图层渲染而是分块展示
 *      栅格化线程池，专门负责把图块转换为位图数据
 *      生成的位图最后发送给合成线程
 *    3.4 浏览器显示内容
 *      显卡接收到浏览器进程传来的页面后，会合成相应的图像
 *    3.5 介绍回流和重绘
 *      3.5.1 回流也叫重排
 *         对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生回流，包括修改dom几何属性，增删dom等
 *         此时从前面的生成dom树开始的流程需要重新处理
 *      3.5.2 重绘
 *         当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)
 *         不用重新生成dom树，但是会计算样式，跳过了生成布局树和建图层树的阶段，直接生成绘制列表
 *      3.5.3 通过合成达到GPU加速
 * 4. 介绍下xss攻击
 *    4.1 XSS 全称是 Cross Site Scripting(即跨站脚本)，为了和 CSS 区分，故叫它XSS
 *    4.2 类型介绍
 *      4.2.1 存储型：前后端没有做好转义的工作，将脚本保存到服务器，导致未知逻辑在服务端执行
 *      4.2.2 反射型：恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到HTML文档中，执行解析
 *      4.2.3 文档型：中间网络传输中拦截html,添加恶意脚本
 *    4.3 如何防范
 *      4.3.1 无论是在前端和服务端，都要对用户的输入进行转码或者过滤
 *      4.3.2 利用 HttpOnly防止cookie被修改
 *      4.3.3 利用 CSP 浏览器中的内容安全策略
 * 5. 介绍下csrf攻击
 *    5.1 csrf:跨站请求伪造,诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求
 *    5.2 危害：模拟用户登陆状态发送各种get/post请求
 *    5.3 防范：利用Cookie的SameSite属性，CSRF Token
 * 6. 介绍下https
 *    6.1 描述：在HTTP和TCP之间建立了一个中间层，这个中间层也叫安全层。安全层的核心就是对数据加解密
 *    6.2 对称加密和非对称加密
 *    6.3 数字证书认证：防止DNS劫持，目的就是让服务器证明自己的身份
 * 7. 进程&线程的理解（注意区分浏览器&js语言自身）
 *    7.1 进程是cpu资源分配的最小单位，相互独立，一般不需要彼此通信
 *    7.2 线程是cpu调度的最小单位，一个进程中可以有多个线程，共享进程资源，主线程可以调度子线程（还是最大效率使用CPU和内存）
 *    7.3 浏览器是多进程的：浏览器的主进程（负责协调、主控），第三方插件进程，GPU进程，浏览器渲染进程（内核）等
 *    7.4 重点展开浏览器渲染进程（由多线程组成），包含哪些线程呢
 *      7.4.1 GUI渲染线程，负责渲染浏览器界面就是前面说的解析&渲染过程
 *      7.4.2 GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起
 *    7.5 JS引擎线程
 *      7.5.1 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎），描述一段js脚本是如何解析运行的
 *    7.6 其它的类似 事件触发线程/定时触发器线程/异步http请求线程，调度由这些线程处理，最后根据事件队列交给js线程
 *    7.7 JS就真的对cpu密集型计算无能为力么？
  */

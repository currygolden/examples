
/**
 * tips: 方法论始终贯穿其中，明白前端/后端/数据在产品周期扮演的角色，主要架构存在什么问题
 * 1. 前端工程化”的定义：
 *    前端架构”的定义是一系列工具和流程的集合，旨在提升前端代码的质量，并实现高效、可持续的工具流
 * 2. 整体进度（时间纬度）
 *      2.1 脚手架方案：提供工程搭建；ui/libs研发资源；规范系统的CI/CD；质量检测体系
 *      2.2 标准化：同类项目有多套规范及协作工具，团队共存多套同类工具，低水平轮子多，维护成本高；工具没有形成生态，不能发挥规模效应
 *          需求规范：MRD-PM-PMO-RD之间的共识
 *          设计规范：UI物料库 基础组件-业务组件-区块模版-页面模版-项目模版
 *          研发规范：统一研发框架工具 xxxCLI 散乱的工具难以发挥规模效应，无法形成生态,架构采用微内核和可插拔插件体系
 *          架构规范：实现自动化项目创建流程（自动接入基础服务），抽象场景模板满足多场景定制化需求
 *          发布规范：流水线持续集成 + 静态网站托管，检查/测试/发布
 *          运维规范：日志告警+coe
 *          规范落地：“普法”加“执法”落地标准化
 *      2.3 平台化：整体架构从下往上是规范-实践，从左往右是流程，生命周期
 *      2.4 云平台：
 *          AirLowCode 低代码研发探索
 *          在线研发工具 WebIDE
 *  3. 云开发平台整体架构
 *  4. 工程化专注解决面临的问题，还有一些基础能力需要其它服务支持
 *  5. 按产品生命周期
 *     需求评审阶段
 *     开发阶段
 *     联调阶段
 *     部署上线
 *     CI/CD
 *     性能监控
 *     质量稳定性
 */

/** =====================
 * 1. 工程化前半部分解决规范，开发构建等问题，还有部署，监控告警等，这里介绍CI/CD 和自动化部署
 *  1.1 现代前端工程的打包产物
 *  1.2 浏览器的缓存策略，此时解决html和静态资源的缓存策略
 *  1.3 构建时依据环境变量，将 HTML 中的静态资源地址加上 CDN 域名(publicPath 改造)。
 *  1.4 构建完成后将静态资源上传到 CDN 。
 *  1.5 配置 Nginx 的反向代理，将静态资源流量转发到 CDN
 *    === 以上属于静态资源的管理和组织
 *
 * 2. 自动化构建方案大致包含
 *  2.1 clone / checkout branch / lint&test/ yarn install / 构建 / 发布流水线&人工卡点 / 资源上传cdn等等
 *  2.2 保证环境一致性：Docker
 *  2.3 按流程构建：Jenkins
 *  2.4 自动化构建触发：Gitlab webhook（这一部分了解流程，实践还不够）
 *
 * 3. 预发环境、版本管理（秒级回滚）、小流量、灰度、AB测试（发布服务支持）

  */

/**
 * 1. 怎么理解前端工程化 talos平台
 *    1. 广义的定义是：以降低成本、提高效率、保障质量为目的，通过一系列规范、工具、流程（分别对应软件工程中的方法、工具和过程）作为手段的实践体系
 *    2. 纵向上看：定义规范，原子物料标准化，CI/CD,托管服务
 *    3. 横向上看：支持常见的如前端的工程从创建、开发、统一构建、持续集成、持续交付、统一部署、自助运维、数据运营等一系列需求
 * 2. 具体在业务里怎么落地工程化
 *    1. 结合团队资源和业务周期，向外看也向内看，核心节点的打通走向平台化（devops）
 *    2. 多角度整理产出规范，从需求评审，开发到最终的稳定性观测全流程
 *    3. 标准化脚手架：以vue社区为例脚手架复制项目创建，generator（模块）
 *      3.1 构建，部署以开放性原则支持插件，支持第三方集成
 *    4. 沉淀业务物料
 *      4.1 组件库，工具库沉淀
 *      4.2 典型业务场景输出统一模块，业务模版，提供物料市场，避免重复低水平造轮子
 *    5. CI：结合webhooks，基于master部署主干泳道
 *    6. CD: 支持自定义发布流水线，满足不同业务线场景，结合具体生命周期如构建前后，发布前后等
 *    7. 托管：前后端分离架构，静态资源部署s3
 *        7.1 前端服务&域名统一管理
 *        7.2 网关层设计：实现灰度、服务降级及 SSR 能力
 *          1. http服务治理以及前端网关层配置，解决路由管理，负载均衡等
 *    8. 综合运维（SLA指标定义）
 *        8.1 项目监控，观测
 *        8.2 支持回滚
 * 3. 最终产出输出了什么
 *    3.1 一系列规范-文档-流程
 *    3.2 npm包：eslint等相关工作流配置
 *    3.3 脚手架：涵盖项目创建，选项配置的设计，打包构建自定义bin
 *    3.4 业务基建物料：常用业务模块
 *    3.5 一系列CD流水线插件
 *    3.6 监控平台&业务监控方案
 * 4. 有体现在定量上的结果吗
 *
 *
 *
 *
 * 10. 一些领域知识
 *    10.1 前后端网关的功能
 *      前后端网关是两个不同的概念，分别指代前端服务层和后端服务层的网关。
 *      前端网关一般是指客户端和后端服务之间的接口层，主要负责管理请求路由、负载均衡、安全认证、缓存处理、监控等流程，对于前端开发者而言，前端网关就是连接客户端和后端服务的入口，保证了前端服务对后端服务的访问。
 *      而后端网关一般是在 API 网关这个层次使用，主要负责服务网格中微服务的访问控制、路由和负载均衡、服务动态配置、限流防刷等功能。其作用是隐藏了微服务的细节，通过 SSL 加密和身份验证来确保微服务的安全和可靠性。
 *      总体来说，两种网关均有不同的服务定位，前端网关主要针对前端服务的接口层，负责将客户端请求进行路由、流量控制等操作；后端网关则负责将服务层中的请求转发到相应的微服务中，以实现高效的负载均衡、安全认证和流量掌控等功能。
 *    10.2 nginx 常见知识点如下
 *       1. 什么是反向代理：在cs之间有一层代理服务器，反向代理就是将请求从客户端转发到内部的服务器上，然后将请求结果反馈给客户端
 *          客户端不知道真正提供服务的是哪个服务器，因此称之为“反向代理”。反向代理不仅可以提供负载均衡、缓存、安全性等功能，还可以屏蔽具体服务器的存在，提高整个系统的可靠性和安全性。
 *          负载均衡：反向代理服务器将所有请求转发到后端的多台服务器，从而实现负载均衡，避免某一台服务器过载。
 *          缓存：反向代理服务器可以缓存请求结果，从而减少后端服务器的压力，提升服务速度。
 *          安全：反向代理服务器可以对请求进行过滤和分析，有效屏蔽恶意请求、攻击和垃圾流量，提高系统的安全性。
 *          透明性：由于反向代理服务器屏蔽了真实的服务提供者，因此可以实现更为灵活的系统配置和管理，方便进行维护。
 *       2. https://github.com/dunwu/nginx-tutorial （nginx 教程和常见配置）
 *    10.3 如何开发一个脚手架 （https://github.com/woai3c/Front-end-articles/issues/22）
 *
 *
 *
 *
 *
 *
 *
 */


/**
 * 具体去做不要担心，核心在于预期什么样的结果和是否沉淀影响力
 * 1. 工程化最大的问题是容易导致碎片化物料和低水平重复
 *    1. 各种非标物料，业务场景脚手架
 *    2. 无法解决多业务线问题，影响力有限
 *    3. 工程能力碎片化，缺少协同能力和沉淀；
 *    4. 重复踩坑，能力缺乏积累，导致交付质量不高；
 *    5. 基建弱。
 * 2. 谈到工程化应该有从下往上，从左往右的架构图
 *    1. 从下往上是
 *    2. 规范可以结合业务实际，参考行业标准，可以是代码规范，流程规范等
 *    3. 原子标准化是为了规范基础物料，细分到具体的业务场景，可以是组件库，工具库
 *      3.1 Generator： 沉淀可复用的模版&基础物料（业务反馈基建）
 *    4. CI/CD是Pipeline 对质量、体验的约束与检测，前者是合并部署主干，后者是发布全流程优化，需要支持第三方改造
 *    5. 托管服务：采用前后端分离的s3资源托管
 *        1. 打通域名与前端项目关联配置
 *        2. 基于网关平台的（移除node层）
 *    6. 从左往右看是软件开发全生命周期
 *        1.
 *        2. 也支持自定义需求场景
 *        3. 开放式、可定制流水线能力的核心诉求
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

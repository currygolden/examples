
/* 
http 基础知识文章参考： https://juejin.cn/post/6844904100035821575

*/

/* 
tcp 知识点参考： https://juejin.cn/post/6844904070889603085

*/

/**
 * 浏览器的缓存机制
 * 1. 缓存的方式
 *    强缓存 协商缓存 缓存位置
 * 2. 缓存判断过程
 *    2.1 检查强缓存，这个阶段不需要发送HTTP请求
 *      Expires： 问题在于时间可能不一致
 *      Cache-Control：private no-cache
 *    2.2 强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求
 *      Last-Modified
 *      ETag 基于内容
 *    若命中缓存返回304，告诉浏览器直接用缓存
 * 3. 缓存位置
 *    优先级由高到低 Service Worker/Memory Cache/Disk Cache/Push Cache
 *    
 * 
 * ==========
 *  浏览器的本地存储
 *  1. cookie
 *    1.1 设计目的：用来做http状态记录，存在跨域限制
 *    1.2 特点：体积上限只有4KB，紧跟域名会导致请求头增大，存在安全问题
 *  2. storage
 *    2.1 只存在客户端，默认不参与与服务端的通信
 *    2.2 容量上限为5M
 *    2.3 可以在客户端做一些数据的持久化存储
 *    2.4 业务中使用本地存储的封装场景
 * 
 * ========= 从输入url到页面呈现详细拆解
 *  1. 输入URL到页面呈现发生了什么？——网络篇
 *    1.1 构建请求行
 *    1.2 查找强缓存
 *    1.3 DNS解析：将域名解析成ip地址
 *      1.3.1 从浏览器缓存获取
 *      1.3.2 从本地hosts文件获取
 *      1.3.3 各级域名解析服务器获取
 *         可以看出DNS的解析是一个递归&迭代的过程
 *      1.3.4 分布式服务器，负载均衡，预解析等做DNS解析优化
 *    1.4 建立tcp连接
 *      1.4.1 面向连接的、可靠的、基于字节流的传输层通信协议
 *      1.4.2 3次握手的流程和必要性 
 *          c发送syn报文，syn=1,序号为x（初始化序列号，是随机生成的）
 *          s接受后发送应答syn报文，syn=1,ACK=1,确认号ack=x+1,序号y
 *          c发送应答报文syn=1,ACK=1,确认号ack=y+1,序号x+1
 *          必要性是为了保证cs双方正常都有发送和响应的能力，两次只能保证s端不能保证C端
 *      1.4.3 什么是半连接队列
 *          服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列
 *      1.4.4 ISN是固定的吗
 *      1.4.5 4次挥手的流程&必要性
 *          c端发送fin报文，序列号为x
 *          s端发送接受报文ACK=1，ack=x+1,序列号为y
 *          s端发送fin报文，ack=x+1,序列号为k(这里的序列号是新的)
 *          c端发送接受报文，ack=K+1,序号为x+1
 *          经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态
 *          4次是为了服务端的数据发送完毕
 *      1.4.6 四次挥手释放连接时，等待2MSL的意义
 *          保证客户端发送的最后一个ACK报文段能够到达服务端
 *          防止“已失效的连接请求报文段”出现在本连接中
 *    1.5 发送http请求
 *       1.5.1 发送请求行，请求头，请求体
 *          请求行：请求方法、请求URI和HTTP版本协议
 *          请求头：accept,压缩方式，cookie，host
 *          请求体: post请求
 *    1.6 处理网络响应
 *        1.6.1 响应行、响应头和响应体
 *        1.6.2 axios的封装
 * 2. 输入URL到页面呈现发生了什么？——解析篇
 *    2.1 拿到html之后的解析过程
 *        2.1.1 由html字符串构建dom树
  */
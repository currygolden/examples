/*
 * @Author: liyu38 liyu38@meituan.com
 * @Date: 2022-05-07 15:31:23
 * @LastEditors: liyu liyu38@meituan.com
 * @LastEditTime: 2022-07-18 20:03:15
 * @FilePath: /examples/fe-web/工程化/微前端.js
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * 参考文档：
 *  https://juejin.cn/post/7004661323124441102
 */
/**
 * 1. 在业务中落地微前端实际遇到什么问题，或者说micro的目标是
 *    解耦巨石应用
 *    落地微前端，根据业务或者模块拆分系统，可以更好的维护
 *    独立开发，独立部署，独立上线
 *    与技术栈无关
 *    形成开发体系
 *  1.1 主应用+子应用体系采用怎样的运行时框架
 *    社区：乾坤，静态资源版本
 *  1.2
 * 2. 微前端体系
 *  2.1 治理体系
 *    应用管理 依赖管理 产物管理 版本发布 灰度方案 私有化
 *  2.2 运行时容器
 *    应用加载 生命周期 路由同步 应用通信 隔离沙箱 异常处理
 *  2.3 开发配套
 *    文档 脚手架 dev 构建 发布 devtools(CI/CD)
 *  2.4 微物料
 *    粒度不一的资源体系
 *
 *
 *
 *
 *
 *
  */



/**
 * @description: 企业内部的微前端方案拆解
 * 1: 思想是组件即服务，可以将应用或者单组件改造成云组件（用唯一的id关联，托管静态资源即可）
 *    1.1 container组件，实现动态组件/动态配置的基础（调度，管理静态资源）
 *    1.2 可视化管理端：策略下发，版本下发，配置中心
 *    1.3 cli工具
 * 2: 提供容器组件通过获取相应的静态资源，此时相比之前浏览器接管，容器接管静态资源做了什么工作（如此设计的目的是什么）
 *    2.1 template构造类
 *      2.1.1: 看起来定义了完整的生命周期，从启动到结束
 *      2.1.2: 容器组件起到代理的作用，edcId 关联的组件获取的是组件相关的静态资源链接（并不是直接获取静态资源，此时只是获取对应的链接）
 *      2.1.3: template类获取script，插入文档，获取style链接，插入文档
 *    2.2 instance 构造类
 *      2.2.1 管理instance 的构造函数，而具体的方法在registry 类，而 instance 实例包含template属性
 *    2.3 registry构造类
 *      2.3.1 registry里管理调度instance 和 template
 * 3. container 容器
 *    3.1 实现 edcInstance，看起来就是渲染一个vue组件的各种属性（将静态资源手动渲染成需要的结构）
 * 4. 核心原理： 总体理解是基于静态资源管理云组件，加工静态资源，注入宿主环境配置，渲染成相应的目标产物
 *    4.1 基于静态资源和工程化配置生成 模版&上下文
 *    4.2 桥接组件处理生命周期和实际的渲染过程（以vue为例，使用渲染函数只依赖运行时能力）
 *    4.3 整体在设计上还需要考虑到 性能和模块化以及web的典型能力
 */


/**
 * @description qiankun的实现
 * 1. 主应用路由拦截（类似router），监听触发事件的回调
 *    1.1 也包括触发路由变化的事件的监听
 *    1.2 在路由变化时候处理子应用的生命周期
 * 2. 子应用生命周期
 *    2.1 固定执行的事件&暴露给开发者的事件
 * 3. 资源加载与解析(html入口)
 *    3.1 html 中资源路径的拼接
 *      3.1.1 对于本地和实际环境就是静态资源路径的差别
 *    3.2 css/js等资源的解析与加载
 * 4. 性能优化&边界问题讨论
 *
 */

/*
 * 参考文档：
 * https://juejin.cn/post/7004661323124441102（实现基于spa的微前端框架）
 * https://github.com/woai3c/Front-end-articles/issues/31（教程）
 * https://qiankun.umijs.org/ 乾坤
 *
 * 技术选型
 * https://juejin.cn/post/7178819246288764986
 * https://juejin.cn/post/7113503219904430111
 * node-module: 企业
 */
/**
 * 1. 在业务中落地微前端实际遇到什么问题，或者说micro的目标是（当前背景，遇到的问题，目标是什么，预期有什么价值）
 *    解耦巨石应用，根据业务或者模块拆分系统，可以更好的维护
 *    独立开发，独立部署，独立上线（核心价值）
 *    与技术栈无关（核心）
 *    在微前端背景下完善基建，包括研发物料和工程体系（核心价值）
 *  1.1 技术方案产出
 *    1.1.1 调研社区方案，结合自身业务特点，分析关键因素优劣
 *    1.1.2 采用何种方案，给出架构图，流程图，目标规划和时间安排
 *    1.1.3 方案说清楚如何服务于目标，目标一定是可以定性以及定量描述的
 *
 *  1.2 方案调研及对比
 *    1.2.1 edc方案
 *      edc主要是关注静态资源，不限组件或者项目，通过容器组件将静态资源也即是vNode渲染到目标dom节点,需要深入理解render函数,容器组件主要对接生命周期逻辑
 *      优点：组件即服务，可以做到组件级的微服务，版本管理，工程生态相对完善
 *      缺点：约定配置太多大版本跟不上社区，js入口
 *    1.2.2 iframe 方案
 *      白屏，刷新，路由前后跳转都是问题，属于降级备选方案
 *    1.2.3 基于 spa 的 qiankun 方案
 *      1.2.3.1 如何实现qiankun
 *        基于路由管理，典型的html入口实现的方案，应用级别
 *        路由变化对应加载不同的子应用，从html里解析出静态资源，处理预加载，缓存和执行沙箱
 *        基于spa的路由方案实现无刷新
 *    1.2.4 micro-app方案
 *      1.2.4.1 核心：是基于html入口和webcomponents 实现，根据micro-app提供url属性
 *      1.2.4.2 优点：对子应用改动下
 *              缺点：还是html入口，每一个子应用得需要有html,离组件即服务还是存在距离
 *    1.2.5 wuji 方案（可以目的性阅读源码）
 *      依然是html入口，不过在之前的框架上针对性的处理了典型问题，是结合iframe的特性
 *  1.3 技术选型，结合业务定义目标
 * 2. 微前端架构
 *  2.1 治理体系
 *    应用管理 依赖管理 产物管理 版本发布 灰度方案 私有化
 *  2.2 运行时容器
 *    应用加载 生命周期 路由同步 应用通信 隔离沙箱 异常处理
 *  2.3 开发配套
 *    文档 脚手架 dev 构建 发布 devtools(CI/CD)
 *  2.4 微物料
 *    粒度不一的资源体系
 *
 *
 *
 *
 *
 *
  */



/**
 * @description: 企业内部的微前端方案拆解
 * 1: 思想是组件即服务，可以将应用或者单组件改造成云组件（用唯一的id关联，托管静态资源即可）
 *    1.1 container组件，实现动态组件/动态配置的基础（调度，管理静态资源）
 *    1.2 可视化管理端：策略下发，版本下发，配置中心
 *    1.3 cli工具
 * 2: 提供容器组件通过获取相应的静态资源，此时相比之前浏览器接管，容器接管静态资源做了什么工作（如此设计的目的是什么）
 *    2.1 template构造类
 *      2.1.1: 看起来定义了完整的生命周期，从启动到结束
 *      2.1.2: 容器组件起到代理的作用，edcId 关联的组件获取的是组件相关的静态资源链接（并不是直接获取静态资源，此时只是获取对应的链接）
 *      2.1.3: template类获取script，插入文档，获取style链接，插入文档
 *    2.2 instance 构造类
 *      2.2.1 管理instance 的构造函数，而具体的方法在registry 类，而 instance 实例包含template属性
 *    2.3 registry构造类
 *      2.3.1 registry里管理调度instance 和 template
 * 3. container 容器
 *    3.1 实现 edcInstance，看起来就是渲染一个vue组件的各种属性（将静态资源手动渲染成需要的结构）
 * 4. 核心原理： 总体理解是基于静态资源管理云组件，加工静态资源，注入宿主环境配置，渲染成相应的目标产物
 *    4.1 基于静态资源和工程化配置生成 模版&上下文
 *    4.2 桥接组件处理生命周期和实际的渲染过程（以vue为例，使用渲染函数只依赖运行时能力）
 *    4.3 整体在设计上还需要考虑到 性能和模块化以及web的典型能力
 * 5. 组件即服务需要比应用即服务更进一步
 *    5.1 乾坤类框架主要是处理节点替换，动态加载执行静态资源，应用通过生命周期与基座交互
 *    5.2 到了组件这里似乎粒度更小，提供一段静态资源，可以替换页面的dom节点，与当下的技术栈无关（这种动态化能力在微前端/低代码/跨端渲染都可以应用）
 *    5.1 容器组件做了什么
 *      0: 处理组件的生命周期逻辑（对应具体的框架）
 *      1: 根据配置生成edc实例
 *      2: 解析出实例的上下文context，并挂载当前容器组件的属性
 *        2.1 主要是确定edcResources和具体的上下文（对应的数据处理阶段）
 *        2.2 生命周期函数具体执行的都是实例的 callhook,即容器组件生命周期的事情都由edc实例来调度
 *        2.3 此时提问生命周期执行和render函数执行是什么关系
 *        2.4 容器组件的render函数
 *          2.4.1 没有complier，只需要运行时即可，最终生成需要的Vnode
 *      3: 此时看容器组件本身做了什么就比较好理解了
 *        3.1 实现框架本身的生命周期函数逻辑，具体需要做什么由edc实例调度
 *        3.2 执行本身的render函数（render数据来源于edc实例）
 *        3.3 所以得进一步分析edc实例到底包含什么
 *      4. 实例由EDCRegistry提供
 *         4.1 有oop的设计，看起来是管理实例，管理模版，初始化的时候更新配置&开启热更新
 *            4.1.1 createInstance：具有template，context
 *            4.1.2 template 是根据资源请求并处理静态资源，把静态资源插入到html中（至于最终节点往哪渲染会去找el属性，在容器组件里完成）
 *            4.1.3 context 由实例和Registry新建（这里的构造类互相当属性）
 * 6. 总结
 *   6.1 组件即服务提供了动态化的视角，
 *   6.2 应用级别的微前端是拦截路由，切换激活的子应用（失活旧的子应用）
 *      6.2.1 此时入口是子应用的html,会做如下操作
 *        1: 提取 HTML 中 script style 的内容或 URL，如果是 URL，则再次使用 ajax 拉取内容。最后得到入口页面所有的 script style 的内容
 *        2: 将所有 style 添加到 document.head 下，script 代码直接执行
 *        3: 将剩下的 body 部分的 HTML 内容赋值给子应用要挂载的 DOM 下
 *          3.1 对于传统spa项目就是挂载点和动态插入的js，此时就可以保证子应用渲染后对应挂载
 *      6.2.2 组件即服务的思想
 *        1: 获取静态资源即可（无论是应用级别还是组件级别）
 *        2: 容器组件负责组织静态资源，渲染实例，挂载dom,同时维护对应的生命周期钩子
 *      6.2.3 版本管理/工程化角度设计
 *        1: 子应用的上线管理，历史版本管理
 *        2: 包治理，性能优化等等
 */


/**
 * @description qiankun的实现
 * 1. 主应用路由拦截（类似router），监听触发事件的回调
 *    1.1 也包括触发路由变化的事件的监听
 *    1.2 在路由变化时候处理子应用的生命周期
 * 2. 子应用生命周期
 *    2.1 固定执行的事件&暴露给开发者的事件
 * 3. 资源加载与解析(html入口)
 *    3.1 html 中资源路径的拼接
 *      3.1.1 对于本地和实际环境就是静态资源路径的差别
 *    3.2 css/js等资源的解析与加载
 * 4. 性能优化&边界问题讨论
 *
 */




/**
 * 1. edc 技术体系实现拆解
 *    核心：将任意框架产出的vNode（页面，组件），渲染到页面的任意dom节点，同时实现模块隔离，是典型的js入口
 *   1.1 入口从DynamicComponent开始，表现看是提供一些配置获取静态资源，最终渲染成隔离的子应用
 *   1.2 DynamicComponent是容器组件，loader属性忽略
 *   1.3 提供EDCRegistry 在node包里使用es6模块语法，来自core,输出4个模块
 *   1.4 容器组件的实现
 *      1.4.1 容器组件主要解决如何确定上下文的子节点（子组件），之后调用h函数按需生成目标的vNode，这一点和vue组件本身类似,其它的还处理了组件的生命周期，属性和监听事件，框架层面处理了错误信息
 *      1.4.2 每一个动态组件有一个edc实例，对应一个渲染上下文context，上一步说的组件来自这里,继续往下涉及几个构造类
 *        1.4.2.1 EDCInstance 实例上持有registry _context
 *          其它都是EDCInstance对生命周期的处理，最后多数落在操作模版template，而模版来自registry
 *        1.4.2.2 context构造类 看起来是整合registry和Instance属性，构成整体的访问上下文
 *        1.4.2.3 registry构造类 依赖template和instance
 *        1.4.2.4 template构造类
 *          通过配置参数请求静态资源，会做一些缓存状态类的判断，资源主要就是script(.js) style(.css)文件
 *          js资源怎么处理：创建script标签，填充属性，通过隔离沙箱设置 textContent，插入head
 *          css资源：类似不过没有沙箱隔离
 *
 *  1.5 总结edc主要做的事情（最精简介绍）
 *    1.5.1 子应用打包的静态资源按版本下发，通过动态容器组件，拉取对应的静态资源插入head标签
 *    1.5.2 以vue技术栈为例，主要就是如何实现由静态资源到页面上的dom元素
 *    1.5.3 一般来说静态资源只是运行时文件，不需要再包含编译过程（构建工具处理），容器组件主要做的是处理自身的渲染和处理启动逻辑
 *      1.5.3.1 容器组件提供4中渲染分支（自定义render），loading，error,标签模式，组件模式；这里主要是深入了解render函数，这是容器组件的vNode来源
 *      1.5.3.2 created 生命周期做了一系列初始化操作
 *        工厂函数新建实例（每一个edc组件对应一个实例）
 *        实例初始化根据配置获取静态资源，全部的相关属性在context管理
 *      1.5.3.3 每一份静态资源有单独的运行沙箱，互不影响(沙箱实现)
 *        采用proxy代理，对目标对象的读写分离控制get/set属性
 *      1.5.3.4 静态资源获取的差异
 *        如果是js入口，需要将子应用打包到一个js和css
 *        如果是html入口，正则匹配html里的js/css/img等文件，同时处理子应用publicpath的区别
 *        css文件如果是样式文件，添加style标签，如果是远程资源添加link标签（这里没有实现样式隔离）
 *        js文件类似，添加script标签，但是内容textcontent需要添加沙盒隔离执行环境
 *        涉及到资源获取一般都会做预加载，缓存
 *
 *
 *
 *
 *
 *
 */
